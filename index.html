<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>My Logbook</title>
  <link rel="stylesheet" href="css/logbook.css">

</head>
<body>

  <form class="search-form">
    <input type="text" class="search" placeholder="Climb or Crag">
    <div class="savedBtns hidden">
      <button class="backBtn active"><i class="fa fa-search"></i></button>
      <div class="savedBtnsContainer"></div>
    </div>
    <div class="viewbox">
      <div class="list-container">
        <ul class="suggestions">
          <li><i class="fa fa-chevron-right"></i>Enter climb or crag name to search</li>
        </ul>
        <ul class="favourites hidden"></ul>
        <ul class="memorable hidden"></ul>
      </div>
    </div>
  </form>





<script>

// adapted from ajax type ahead thing


// - steps:
// 1 - fetch data (array from endpoint)
// 2 - type into the input box, filter the text by subset which the climb or crag matches
// 3 - click button, show more info about climb or crag
//    - when a climb is selected, data comes from climb ID (inferred by order in data array)
//    - when a crag is selected, data on all climbs I have done at the crag becomes available



// 1 - get data
// 2 - get functions in place
// 3 - hook up to event listeners


// fetch API will return a promise


// things to try out
// - use geolocation - sort by crags closest to me


// ________________________________________________
const endpoint = 'json/mb-logbook.json';

// use fetch API with the endpoint
const climbs = [];

// const prom = fetch(endpoint);
// console.log(prom); // this will return a promise in the console - no data yet, something will come back


// fetch(endpoint).then(blob => console.log(blob));
// data that comes back from fetch does not yet know what type it is
// - in 'proto' in console log, there is a method called 'JSON'
// -> this returns another promise, which you call then on

fetch(endpoint)
    .then(blob => blob.json())
    // .then(data => console.log(data)) // logs out all items in array
    // .then(data => climbs = data) // this results in an array within the array, should climbs be assigned with 'let'
    .then(data => climbs.push(...data)) // use spread operator to spread into climbs





// find matches function
// - gets climb data for matched text, from the original array

// - can only take strings. Integer 999 stumped this before
// - need to convert integers to strings
function findMatches(wordToMatch, climbs) {
  // filter the climbs - a subset of the initial array
  return climbs.filter(entry => {

    // figure out if the climb or crag matches what was searched
    const regex = new RegExp(wordToMatch, 'gi'); // pass 'flags' you want to search (global, insensitive)    

    // this will filter out integers - e.g. the climb 999
    // - regular expressions only work on strings, original array needs to be changed
    if ( entry.climb === parseInt(entry.climb, 10)){
      // convert entry.climb to an integer and return it?
    } else {
      // call match with regex on climb name or crag name
      return entry.climb.match(regex) || entry.crag.match(regex)
    }

  })
}



// calendar function - used twice
// - year is always present. When not set, it is the 2nd item in the array
function calendarHtml(date) {
  const noDate = date.match(/^\?/);
  const split = date.split("/");
  return `
  <span class="calendar${noDate ? " not-set" : ""}">
    <span class="month">${noDate ? `N/A` : `${split[1]}`}</span>
    <span class="day">${noDate ? `N/A` : `${split[0]}`}</span>
    <span class="year">${noDate ? `${split[1]}` : `20${split[2]}`}</span>
  </span>
  `;
}









// display matches function
// - take value of the input field, convert it into matched items from the data
function displayMatches(){

  // call the findMatches function, passing the value to it
  const matchArray = findMatches(this.value, climbs);

  // compose html
  let html = matchArray.map(entry => {
    
    // format the html - highlight the searchterm:
    // 1 - use a regex to match
    // 2 - wrap match in a span - highlight in yellow
    const regex = new RegExp(this.value, 'gi');
    const climbName = entry.climb.replace(regex, `<span class="hl">${this.value}</span>`);
    const cragName = entry.crag.replace(regex, `<span class="hl">${this.value}</span>`);
    
    // add an ID to each climb - for more info on button click
    const climbDate = entry.Date;
    const climbID = climbs.indexOf(entry); // search for entry (item in 'climbs' array)

    // format the date a bit nicer - use calendar function
    // const dateHtml = calendarHtml(climbDate);
    
    return `
      <li class="searched" data-date="${climbDate}" data-id="${climbID}">
        <span class="date">${climbDate}</span>
        <span class="name">${climbName}, ${cragName}</span>
        <span class="more"><i class="fa fa-chevron-right"></i></span>
      </li>
    `;
  }).join(''); // this returns an array (of matches), which need to be joined into a string

  // no results message
  if (html.length < 1) {
    html = `<li class="no-results">No results found. Please try again</li>`;
  }
  // add above html to suggestions
  suggestions.innerHTML = html;

  // find out when input is focused. Want to make climb-info work on 1st click
  // - think of mobile as well, can't do on mousemove only
  // - timeout may be best

}



// get DOM nodes
const searchInput = document.querySelector('.search');
const btnContainer = document.querySelector('.savedBtnsContainer');
const suggestions = document.querySelector('.suggestions');
const favourites = document.querySelector('.favourites');
const listContainer = document.querySelector('.list-container');

// listen for the change AND keyup events on the input box
searchInput.addEventListener('change', displayMatches);
searchInput.addEventListener('keyup', displayMatches);


// a way to add event listener to mulitple elements of the same type
// - may not apply here - elements are delegated
// skipButtons.forEach(button => button.addEventListener('click', skip));







// unfocus search input - mouseout for non mobile, timeout (after focus) for mobile
searchInput.addEventListener('mouseout', blurSearch);


// need to unfocus search to allow one click to take you to result
function blurSearch(){
  searchInput.blur();
  // console.log(searchInput);
}







// keep more-info container in view
// - added in container function, results in jerk.
// - probably best to do some absolute positioning
// window.addEventListener('scroll', climbInfoOffset);

// function climbInfoOffset() {
//   const topOffset = window.pageYOffset + 10;
//   listContainer.querySelector('.climb-info').style.marginTop = `${topOffset}px`;
// }





// __________________
// more info buttons

// 1 - get the clicked button
// 2 - get the data associated with it
// 3 - compose html for associated data
// 4 - add html to DOM
// 5 - slide out previous list, slide in new one, with button to slide back
listContainer.addEventListener("click", moreInfo);





// expand object function
// - allow mulitple keys to be assigned to same values - useful for grade colour banding
function expand(obj) {
  const keys = Object.keys(obj);
  for (const key of keys) {
    const subkeys = key.split(/,\s?/);
    const target = obj[key];
    delete obj[key];
    subkeys.forEach(key => { obj[key] = target; })
  }
  return obj;
}


// add faded div if notes section is overflown
function isOverflown(element) {
    return element.scrollHeight > element.clientHeight || element.scrollWidth > element.clientWidth;
}







// switch between list and individual items - ul.suggestions and ul.climb-info
// - forward and back
function moreInfo(e) {


  // more button
  // - this does not fire on first click, only second click. Needs to fire on first
  // - may be because input field is still focused. First click de-focuses input field.
  // NOTE: this section will get bloated - look into ways of splitting js up
  if (e.target && e.target.nodeName == "LI" && e.target.classList.contains('searched')) {


    // offset the .climb-info ul with a top margin
    // - required for elements at the bottom of the page / when scrolled down
    const topOffset = (window.pageYOffset + 10).toString();


    // get the ID (convert to numeric)
    let ID = e.target.getAttribute('data-id');
    ID = parseInt(ID);
    // get the climb from the array
    const ascent = climbs[ID];
    // get full info
    const date = ascent.Date;
    const name = ascent.climb;
    let grade = ascent.Grade; // need to convert to a string - lower grade american routes are numerical in data
    grade = grade.toString();
    const style = ascent.Style;
    const partners = ascent["Partner(s)"];
    const notes = ascent.Notes;
    const crag = ascent.crag;

    

    
    // _________________
    // grade - most complex parameter of the lot
    // - star count, discipline, grade band colour
    // - grade band dependent upon discipline, and grading system
    // - can't tell discipline from grade for roped climbs, unless in UK system

    // order:
    // uk trad, sport / french, USA, norse, bouldering, winter, ice

    // get the grade - first word of string
    const getGrade = grade.split(" ")[0];
    
    // grade bands object
    const gradeBands = expand({

      "M, D, VD, HVD, S, 1, 2, 3, 4a, 4b, 4c, 5.1, 5.2, 5.3, 5.4, 5.5, 5.6, n1, n2, n3, n4, f1, f2, f2+, f3, f3+, I, II, WI-1, WI-2" : {
        band : ' green'
      },
      "HS, MVS, VS, HVS, 5a, 5b, 5c, 6a, 6a+, 5.7, 5.8, 5.9, 5.10a, 5.10b, 5.10c, n5-, n5, n5+, f4, f4+, III, IV, WI-3, WI-4" : {
        band : ' yellow'
      },
      "E1, E2, E3, 6b, 6b+, 6c, 6c+, 7a, 5.10d, 5.11a, 5.11b, 5.11c, 5.11d, n6-, n6, n6+ f5, f5+, f6A, f6A+, V, VI, WI-5" : {
        band : ' red'
      },
      "E4, E5, E6, E7, E8, E9, E10, E11, E12, 7a+, 7b, 7b+, 7c, 7c+, 8a, 8a+, 8b, 8b+, 8c, 8c+, 9a, 9a+, 9b, 9b+, 9c, 5.12a, 5.12b, 5.12c, 5.12d, 5.13a, 5.13b, 5.13c, 5.13d, 5.14a, n7-, n7, n7+, n8-, n, n8+, f6B, f6B+, f6C, f6c+, f7A, f7A+, f7B, f7B+, f7C, f7C+, f8A, VII, VIII, IX, X, WI-6, WI-7" : {
        band : ' black'
      }
      
    });

    // disciplines object
    // const gradeDisciplines = expand({

    //   "M, D, VD, HVD, S, HS, MVS, VS, HVS, E1, E2, E3, E4, E5, E6, E7, E8, E9, E10, E11, E12" : {
    //     discipline : 'UK trad'
    //   },
    //   "1, 2, 3, 4a, 4b, 4c, 5a, 5b, 5c, 6a, 6a+, 6b, 6b+, 6c, 6c+, 7a, 7a+, 7b, 7b+, 7c, 7c+, 8a, 8a+, 8b, 8b+, 8c, 8c+, 9a, 9a+, 9b, 9b+, 9c" : {
    //     discipline : 'French grade - usually sport'
    //   },
    //   "5.1, 5.2, 5.3, 5.4, 5.5, 5.6, 5.7, 5.8, 5.9, 5.10a, 5.10b, 5.10c, 5.10d, 5.11a, 5.11b, 5.11c, 5.11d, 5.12a, 5.12b, 5.12c, 5.12d, 5.13a, 5.13b, 5.13c, 5.13d, 5.14a" : {
    //     discipline : 'American grade - sport or trad'
    //   }
      
    // });

    // grade - get colour brand from object
    const getColour = gradeBands[getGrade].band;
    // console.log(gradeBands[getGrade].band);
    // console.log(gradeDisciplines[getGrade].discipline);


    // regex for discipline - more efficient than an object
    let discipline;
    if (grade.match(/^W/)) {
      discipline = 'ice';
    }
    else if (grade.match(/^M[0-9]/)) { // M followed by a number
      discipline = 'mixed';
    }
    else if (grade.match(/^f/)) {
      discipline = 'bouldering';
    }
    else if (grade.match(/^I|V(?!S|D)/)) { // I or V if not followed by S or D
      discipline = 'winter';
    }
    else if (grade.match(/^[A-Z]/)) { // starts with a capital letter, comes after the above
      discipline = 'UK trad';
    }
    else if (grade.match(/^[1-9][a-c]/)) { // starts with a number, followed by lowercase letter
      discipline = 'French grade - usually sport';
    }
    else if (grade.match(/^5/)) { // starts with a 5
      discipline = 'American grade - sport or trad';
    }
    else if (grade.match(/^n/)) { // starts with a lowercase n
      discipline = 'Norse grade - sport or trad';
    }

    // stars: swap * for fa-star
    const withStars = grade.replace(/\*/g,"<i class='fa fa-star yellow margin-left'></i>");
    const gradeHtml = `<div class="grade"><i class="fa fa-circle${getColour}"></i>${withStars}</div>`;

    // discipline
    const disciplineHtml = `<div class="discipline"><i class="fa fa-chevron-right"></i>${discipline}</div>`;









    
    
    // _________________
    // style
    // Lead (or solo) + (0/S, _, RP, rpt, x) = green (note that '_' is a flash)
    // TR + (0/S, _, G/U, RP, rpt) = blue
    // dog, dnf = red

    let success = /(O\/S|_|G\/U|RP|rpt|x)/;
    success = style.match(success);

    let fail = /(dog|dnf)/;
    fail = style.match(fail);

    // set colour and icon
    let styleColour;
    let styleIcon;
    let styleUnset;
    
    if (fail !== null){
      styleColour = ' red';
      styleIcon = ' fa-close';
    }
    else if (success !== null){
      styleIcon = ' fa-check';
      if (success.input.split(" ")[0] == 'TR' | success.input.split(" ")[0] == '2nd') {
        styleColour = ' blue';
      } else {
        styleColour = ' green';
      }
    }
    else {
      // style has not been set
      styleIcon = ' fa-question';
      styleColour = ' grey';
      styleUnset = ' - style not set';
    }

    // beta: swap _ from data for β
    const withBeta = style.replace(/_/g,"β (flash)");
    const styleHtml = `<div class="style${styleColour}"><i class="fa${styleIcon}"></i>${withBeta} ${styleUnset !== undefined ? `${styleUnset}` : ""}</div>`;



    // _________________
    // partner(s)
    // if string contains a comma. Will break if partner's name does not contain a comma for some reason.
    const partnerPlural = partners.includes(',');
    const partnerHtml = `${partners.length > 0 ? `<div class="partners"><i class="fa fa-user${partnerPlural == false ? "" : "s"}"></i>${partners}</div>`: ""}`;


    // _________________
    // notes
    // - if notes overflow, add an overlay with linear gradient to fade out
    const notesHtml = `
    <div class="notes${notes ? "" : " no-notes"}">
    <i class="fa fa-edit"></i>${notes ? ascent.Notes : "No notes contributed for this climb"}
    </div>`;


    // calendar thing
    const calDate = calendarHtml(date);
    const dateHtml = `<div class="date">${calDate}</div>`;
    
    // add top margin to hold position in the list. Subtract height of searchbar
    const html = `
    <ul class="climb-info"${topOffset > 10 ? ` style="margin-top:${topOffset}px;"` : ""}>
      <li>
        <div class="back">
          ${dateHtml}
          <i class="fa fa-chevron-left"></i>
        </div>
        <div class="climb-details">
          <div class="save" data-id="${ID}"><i class="fa fa-save" title="save details"></i><div class="climb-settings"></div></div>
          <div class="title">${name}</div>
          ${gradeHtml}
          ${disciplineHtml}
          ${styleHtml}
          ${partnerHtml}
          ${notesHtml}
          <div class="crag"><i class="fa fa-map-marker red"></i>${crag}</div>
        </div>
      </li>
    </ul>
    `;

    listContainer.insertAdjacentHTML('beforeend', html);
    listContainer.classList.add('slide-left');
    suggestions.classList.add('shadow-off');

    // keep position of climb-info (prevent scroll)
    document.body.classList.add('fixed');

    // search bar
    searchInput.setAttribute("style", `top:${topOffset}px;`); // set offset
    searchInput.disabled = true; // disable input

    // notes
    // - happens after noesHtml is added to DOM
    // - need to evaluate if text overflows after it has been added to the DOM
    const notesLi = listContainer.querySelector('.notes');

    if (isOverflown(notesLi) == true) {

      notesLi.classList.add('overflow');
      const tallContent = `<i class="fa fa-edit"></i><div>${notesLi.textContent}</div><div class="fade-out"><i class="fa fa-chevron-down"></i></div>`;
      notesLi.innerHTML = "";
      notesLi.insertAdjacentHTML('beforeend', tallContent);
    }



    // ____________________
    // favourite and memorable buttons
    // - if they exist, remove when moving to climb info view

    // favourite
    if(favClimbs.length > 0){
      btnContainer.querySelector('.favBtn').remove();
      btnContainer.parentNode.classList.add('hidden');
      // || memClimbs.length > 0
      // btnContainer.querySelector('.memBtn').remove();
    }
    
    


  }




    







  
  // back button - to suggestions list

  // target back button / icon
  if (e.target && e.target.nodeName == "DIV" && e.target.classList.contains('back')) {

    // slide right
    listContainer.classList.remove('slide-left');
    // add default shadow back to .suggestions
    suggestions.classList.remove('shadow-off');
    // searchbar
    searchInput.setAttribute('style', 'top:10px;'); // position searchbar at top
    searchInput.disabled = false; // enable input

    // remove climb info ul
    // - take delay value from css (transition on list container = 0.5s)
    // - remove 's'
    let time = window.getComputedStyle(listContainer).transitionDuration.slice(0, -1);
    // - multiply by 1000
    time = parseFloat(time)*1000;
    setTimeout(function(){
      listContainer.querySelector('.climb-info').remove();
      document.body.classList.remove('fixed');
    }, time);


    
    
    // ____________________
    // favourite and memorable buttons
    // - add / reveal (if required) when moving back to suggestions list
    const favBtnPresent = btnContainer.querySelector('.favBtn') != null;

    // favourite(s) added
    if(favClimbs.length > 0 && favBtnPresent == false){
      const favBtn = '<button class="favBtn"><i class="fa fa-heart"></i></button>';
      btnContainer.parentNode.classList.remove('hidden');
      btnContainer.insertAdjacentHTML('afterbegin', favBtn); // at start of div. beforeend on memorable
    }
    // no favourite(s)
    if(favClimbs.length == 0){
      btnContainer.parentNode.classList.add('hidden');
      // - make sure suggestions list is visible
      suggestions.classList.remove('hidden');
      favourites.classList.add('hidden');
    }


  }


} // end moreInfo() - individual climbs











// ________________________________________
// show climb save options
function climbSettings(e) {


  // open
  if (e.target && e.target.nodeName == "DIV" && e.target.classList.contains('save')) {
    e.target.classList.add('expanded');
    e.target.parentNode.previousElementSibling.classList.add('no-pointers'); // make back btn non clickable

    let ID = e.target.getAttribute('data-id');
    ID = parseInt(ID);
    const ascent = climbs[ID]; // can get date from ID, then search climbs array for other climbs on this day
    const name = ascent.climb;    
    
    // need to check or uncheck checkboxes
    // - favClimbs array
    const isFav = favClimbs.find(climb => climb.routeID === ID.toString());

    const html = `
    <div class="title">
      ${name}
    </div>
    <div class="favourite">
      <div><i class="fa fa-heart red"></i>Favourite Route</div>
      <div><input type="checkbox" name="favourite" data-id="${ID}" ${isFav ? 'checked' : ''}/><label></label></div>
    </div>
    <div class="memorable-day">
      <div><i class="fa fa-book blue"></i>Memorable Day</div>
      <div><input type="checkbox" name="memorable" data-id="${ID}"/></div>
      <div><textarea placeholder="Add something to remember this day by"></textarea></div>
    </div>
    `;
    
    setTimeout(function(){
      e.target.querySelector('.climb-settings').innerHTML = html;
      e.target.querySelector('.climb-settings').classList.add('slide');
      // checkboxes - save data to local storage
      const checkboxes = Array.from(e.target.querySelectorAll('input[type=checkbox]'));
      checkboxes.forEach(checkbox => checkbox.addEventListener('click', saveClimb));

    }, 1000);
    
  }


  // close
  if (e.target && e.target.nodeName == "I" && e.target.classList.contains('fa-save')) {
    
    e.target.setAttribute('title', 'save details');

    e.target.nextSibling.classList.remove('slide');
    setTimeout(function(){
      e.target.nextSibling.innerHTML = "";
      e.target.parentNode.classList.remove('expanded');
      e.target.parentNode.parentNode.previousElementSibling.classList.remove('no-pointers'); // make back btn clickable again
    }, 1000);

  }
}



listContainer.addEventListener("click", climbSettings);








// ________________________________________
// save options: favourite route, and memorable date
const favClimbs = [];
function saveClimb() {

  const saveType = this.getAttribute('name');
  const routeID = this.getAttribute('data-id');


  // favourite climbs
  if (saveType === 'favourite') {
    // console.log(`favourite route id = ${routeID}`);
    let favourite;

    // checkbox needs to be checked and unchecked in the html to work correctly
    // - this happens with array .find method in the climbSettings function
    if (this.checked) {
      favourite = {
        routeID,
        done : true
      };
      favClimbs.push(favourite);
    } else {
      favClimbs.pop(favourite);
    }

    // output favourites list in html - (array, html selector)
    selectedClimbs(favClimbs, favourites);
  }





  // memorable days
  if (saveType === 'memorable') {
    console.log(`memorable route id = ${routeID}`);
    // if box is checked or text entered - will require another event listener
  }


}





// ________________________________________
// favourite climbs html - make addable anywhere
// - params: array, element to add into
// - note: this recreates the list (html) every time an item is added or removed.
//  - a library or framework may be useful here > smarter + improve performance

// NOTE: a different array method - e.g. reduce may be useful
// - same routes have been climbed multiple times, I am just marking individual ascents here:

// new version: going towards a loop within a loop (for repeat ascents)
function selectedClimbs(selectedClimbs = [], climbsList) {
  climbsList.innerHTML = selectedClimbs.map((climb, i) => {

    // get climb details. climb.routeID = ID (from previous)
    const ascent = climbs[climb.routeID];
    const date = ascent.Date;
    const name = ascent.climb
    const crag = ascent.crag;
    
    
    
    // find if the ascent was a repeat:
    // NOTE: this looks for route name and crag
    // - if 2 crags of the same name both have a route with the same name, this won't work.
    const rptAscent = climbs.filter(climb => (climb.climb === name && climb.crag === crag));

    // another idea:
    // - output all repeat ascents as list items

    // output all favourited ascents
    return `
    <li class="searched favourite" data-date="${date}" data-id="${climb.routeID}" data-index="${i}">
      <span class="date">${date}</span>
      <span class="name">${name}, ${crag}</span>
      <span class="more"><i class="fa fa-chevron-right"></i></span>
      ${rptAscent.length > 1 ? `<span class="repeat">You have climbed <em>'${name}'</em> ${rptAscent.length} times</span>` : ''}
    </li>
    `;
  }).join('');
}








// ________________________________________
// favourite / memorable climbs button clicks
function favMemBtns(e) {  
  e.preventDefault();

  const backBtn = btnContainer.parentNode.querySelector('.backBtn');
  const backBtnActive = backBtn.querySelector('.fa-chevron-left') != null;
  const favBtn = btnContainer.querySelector('.favBtn');

  // favourite
  if (e.target.classList.contains('favBtn')) {
    suggestions.classList.add('hidden');
    favourites.classList.remove('hidden');
    // button
    e.target.classList.add('active');
    backBtn.classList.remove('active');
    // add back chevron if not there
    if (backBtnActive == false) {
      backBtn.insertAdjacentHTML('afterbegin', '<i class="fa fa-chevron-left"></i>');
    }
  }



  // if (e.target.classList.contains('memBtn')) {
  //   console.log('mem');
  // }



  // back
  // - add in back icon when above buttons clicked
  // - need to show suggestions list when searchbar clicked too
  if (e.target.classList.contains('backBtn')) {
    suggestions.classList.remove('hidden');
    favourites.classList.add('hidden');
    // button
    e.target.classList.add('active');
    favBtn.classList.remove('active');
    e.target.querySelector('.fa-chevron-left').remove();
  }

}





btnContainer.parentNode.addEventListener("click", favMemBtns);






// ________________________________________
// image search test
// const imageSearch = require('node_modules/node-google-image-search-promise');

// imageSearch('<search-term>', 0, 5)
//   .then(results => {
//     // do something...
//   });



</script>


<!-- <script src="js/build/client.bundle.js"></script> -->




  </body>
</html>
